{
  "version": 3,
  "sources": ["life/cell.wgsl", "life/simulation.wgsl", "life/life.ts"],
  "sourcesContent": ["@group(0) @binding(0)  var<uniform> grid: vec2f;\n@group(0) @binding(1) var<storage> cellState: array<u32>;\n\nstruct VertexInput {\n    @location(0) pos: vec2f,\n    @builtin(instance_index) instance: u32,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4f,\n    @location(0) cell: vec2f,\n}\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    let i = f32(input.instance);\n    // Compute the cell coordinates from the instance index.\n    let cell = vec2f(i % grid[0], floor(i / grid[1]));\n    // Get the state of the cell.\n    let state = f32(cellState[input.instance]);\n\n    // Canvas is [-1, 1] so we need to scale the grid to fit.\n    let cellOffset = cell / grid * 2;\n    let gridPos = (input.pos * state + 1) / grid - 1 + cellOffset;\n    return VertexOutput(\n        vec4f(gridPos, 0, 1),\n        cell,\n    );\n}\n\nstruct FragmentInput {\n    @location(0) cell: vec2f,\n}\n\n@fragment\nfn fragmentMain(\n    input: FragmentInput,\n) -> @location(0) vec4f {\n    let c = input.cell / grid;\n    return vec4f(c, 1 - c.y, 1.0);\n}\n", "@group(0) @binding(0) var<uniform> grid: vec2f;\n\n@group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n\nfn cellIndex(cell: vec2u) -> u32 {\n    // Supports grid wrapping.\n    return (cell.y % u32(grid.y)) * u32(grid.x) + (cell.x % u32(grid.x));\n}\n\nfn cellActive(x: u32, y: u32) -> u32 {\n    return cellStateIn[cellIndex(vec2(x, y))];\n}\n\n@compute\n@workgroup_size(8, 8) // TODO: Use templates for WORKGROUP_SIZE?\nfn computeMain(@builtin(global_invocation_id) cell: vec3u) {\n    var x: u32 = 0;\n    x += cellActive(cell.x + 1, cell.y + 1);\n    x += cellActive(cell.x + 1, cell.y);\n    x += cellActive(cell.x + 1, cell.y - 1);\n    x += cellActive(cell.x, cell.y - 1);\n    x += cellActive(cell.x - 1, cell.y - 1);\n    x += cellActive(cell.x - 1, cell.y);\n    x += cellActive(cell.x - 1, cell.y + 1);\n    x += cellActive(cell.x, cell.y + 1);\n\n    let i = cellIndex(cell.xy); // Called swizzling cell.xy == vec2(cell.x, cell.y)\n\n    // Conway's game of life rules:\n    switch x {\n        case 2: { // Active cells with 2 neighbors stay active.\n            cellStateOut[i] = cellStateIn[i];\n        }\n        case 3: { // Cells with 3 neighbors become or stay active.\n            cellStateOut[i] = 1;\n        }\n        default: { // Cells with < 2 or > 3 neighbors become inactive.\n            cellStateOut[i] = 0;\n        }\n    }\n}\n", "// WebGPU life game example.\n//\nconst GRID_SIZE = 32;\nconst UPDATE_INTERVAL = 200; // 5 FPS\nlet step = 0; // Track how many simulation steps have been run\nconst WORKGROUP_SIZE = 8;\n\nimport CellShader from \"./cell.wgsl\";\nimport SimulationShader from \"./simulation.wgsl\";\n\nconst canvas = document.querySelector(\"canvas\");\nif (!canvas) {\n  throw new Error(\"No canvas found.\");\n}\n\nif (!navigator.gpu) {\n  throw new Error(\"WebGPU not supported on this browser.\");\n}\nconsole.log(\"WebGPU is supported!\");\n\nconst adapter = await navigator.gpu.requestAdapter();\nif (!adapter) {\n  throw new Error(\"No appropriate GPUAdapter found.\");\n}\n\nconst device = await adapter.requestDevice();\n\nconst context = canvas.getContext(\"webgpu\");\nif (!context) {\n  throw new Error(\"No context found.\");\n}\n\nconst canvasFormat = navigator.gpu.getPreferredCanvasFormat();\ncontext.configure({\n  device: device,\n  format: canvasFormat,\n});\n\nconst vertices = new Float32Array([\n  // X,  Y,\n  -0.8, -0.8, // Triangle 1\n  0.8, -0.8,\n  0.8, 0.8,\n\n  -0.8, -0.8, // Triangle 2 \n  -0.8, 0.8,\n  0.8, 0.8,\n]);\n\nconst vertexBuffer = device.createBuffer({\n  // Labels are useful for debugging.\n  label: \"Cell vertices\",\n  // 4 bytes * 12 vertices = 48 bytes.\n  size: vertices.byteLength,\n  // The buffer will be used as the source of vertex data.\n  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\ndevice.queue.writeBuffer(vertexBuffer, /* offset */ 0, vertices);\n\nconst vertexBufferLayout: GPUVertexBufferLayout = {\n  // 2 floats for position.\n  arrayStride: 8,\n  attributes: [{\n    format: \"float32x2\",\n    offset: 0,\n    shaderLocation: 0, // Position, see vertex shader\n  }],\n};\n\n// Create a uniform buffer that describes the grid.\nconst uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);\nconst uniformBuffer = device.createBuffer({\n  label: \"Grid uniforms\",\n  size: uniformArray.byteLength,\n  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n});\ndevice.queue.writeBuffer(uniformBuffer, 0, uniformArray);\n\n// Create an array represnting the active state of each cell.\nconst cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);\n// Create a buffer to store the cell state.\nconst cellStateStorage: Array<GPUBuffer> = [\n  device.createBuffer({\n    label: \"Cell state A\",\n    size: cellStateArray.byteLength,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n  }),\n  device.createBuffer({\n    label: \"Cell state B\",\n    size: cellStateArray.byteLength,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n  }),\n];\n// Initialize the cell state.\nfor (let i = 0; i < GRID_SIZE * GRID_SIZE; i += 3) {\n  cellStateArray[i] = Math.random() > 0.6 ? 1 : 0;\n}\ndevice.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);\ndevice.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray);\n\n\nconst cellShaderModule = device.createShaderModule({\n  label: \"Cell shader\",\n  code: CellShader,\n});\n\n// Create a bind group layout.\n// We cannot use the pipeline layout because the compute shader needs a\n// different bind group layout. \"auto\" doesn't know about the compute shader.\nconst bindGroupLayout = device.createBindGroupLayout({\n  label: \"Cell bind group layout\",\n  entries: [{\n    binding: 0,\n    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n    buffer: { type: \"uniform\" },\n  }, {\n    binding: 1,\n    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n    buffer: { type: \"read-only-storage\" },\n  }, {\n    binding: 2,\n    visibility: GPUShaderStage.COMPUTE,\n    buffer: { type: \"storage\" },\n  }],\n});\n\nconst bindGroups = [\n  device.createBindGroup({\n    label: \"Cell render bind group A\",\n    layout: bindGroupLayout, // Corresponds to @group(0) in the shader.\n    entries: [{\n      binding: 0, // Corresponds to @binding(0) in the shader.\n      resource: { buffer: uniformBuffer },\n    }, {\n      binding: 1, // Corresponds to @binding(1) in the shader.\n      resource: { buffer: cellStateStorage[0] },\n    }, {\n      binding: 2, // Corresponds to @binding(2) in the shader.\n      resource: { buffer: cellStateStorage[1] },\n    }],\n  }),\n  device.createBindGroup({\n    label: \"Cell render bind group B\",\n    // The layout is derived from the `layout: \"auto\"` in the pipeline.\n    layout: bindGroupLayout, // Corresponds to @group(0) in the shader.\n    entries: [{\n      binding: 0, // Corresponds to @binding(0) in the shader.\n      resource: { buffer: uniformBuffer },\n    }, {\n      binding: 1, // Corresponds to @binding(1) in the shader.\n      resource: { buffer: cellStateStorage[1] },\n    }, {\n      binding: 2, // Corresponds to @binding(2) in the shader.\n      resource: { buffer: cellStateStorage[0] },\n    }],\n  }),\n];\n\nconst pipelineLayout = device.createPipelineLayout({\n  label: \"Simulation pipeline layout\",\n  bindGroupLayouts: [bindGroupLayout],\n});\n\nconst cellPipeline = device.createRenderPipeline({\n  label: \"Cell pipeline\",\n  layout: pipelineLayout, // Can't use \"auto\".\n  vertex: {\n    module: cellShaderModule,\n    entryPoint: \"vertexMain\",\n    buffers: [vertexBufferLayout]\n  },\n  fragment: {\n    module: cellShaderModule,\n    entryPoint: \"fragmentMain\",\n    targets: [{\n      format: canvasFormat,\n    }],\n  },\n});\n\nconst simulationShaderModule = device.createShaderModule({\n  label: \"Game  of Life simulation shader\",\n  code: SimulationShader,\n});\n\nconst simulationPipeline = device.createComputePipeline({\n  label: \"Simulation pipeline\",\n  layout: pipelineLayout,\n  compute: {\n    module: simulationShaderModule,\n    entryPoint: \"computeMain\",\n  },\n})\n\n\nfunction updateGrid() {\n  if (!context) {\n    throw new Error(\"No context found.\");\n  }\n\n  const encoder = device.createCommandEncoder();\n\n  // Start a compute pass.\n  const computePass = encoder.beginComputePass();\n  computePass.setPipeline(simulationPipeline);\n  computePass.setBindGroup(0, bindGroups[step % 2]); // Corresponds to @group(0) in the shader.\n  const workgroupCount = Math.ceil(GRID_SIZE / WORKGROUP_SIZE);\n  computePass.dispatchWorkgroups(workgroupCount, workgroupCount, 1);\n\n  computePass.end();\n\n  step++;\n\n  // Start a render pass.\n  const pass = encoder.beginRenderPass({\n    label: \"Cell render pass\",\n    colorAttachments: [{\n      view: context.getCurrentTexture().createView(),\n      loadOp: \"clear\",\n      storeOp: \"store\",\n      clearValue: { r: 0.11, g: 0.11, b: 0.12, a: 1.0 }, // Can pass as an array as well.\n    }],\n  });\n\n  // Create the grid.\n  pass.setPipeline(cellPipeline);\n  pass.setVertexBuffer(0, vertexBuffer);\n  pass.setBindGroup(0, bindGroups[step % 2]); // Corresponds to @group(0) in the shader.\n  pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE); // Instance count is the number of squares.\n\n  pass.end();\n  // Finish the command buffer and immediately submit it.\n  device.queue.submit([encoder.finish()]);\n}\n\n// Schedule updateGrid to run repeatedly.\nsetInterval(updateGrid, UPDATE_INTERVAL);\n"],
  "mappings": "AAAA,IAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ECAA,IAAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ECEA,IAAMC,EAAY,GACZC,EAAkB,IACpBC,EAAO,EACLC,EAAiB,EAKjBC,EAAS,SAAS,cAAc,QAAQ,EAC9C,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,kBAAkB,EAGpC,GAAI,CAAC,UAAU,IACb,MAAM,IAAI,MAAM,uCAAuC,EAEzD,QAAQ,IAAI,sBAAsB,EAElC,IAAMC,EAAU,MAAM,UAAU,IAAI,eAAe,EACnD,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,kCAAkC,EAGpD,IAAMC,EAAS,MAAMD,EAAQ,cAAc,EAErCE,EAAUH,EAAO,WAAW,QAAQ,EAC1C,GAAI,CAACG,EACH,MAAM,IAAI,MAAM,mBAAmB,EAGrC,IAAMC,EAAe,UAAU,IAAI,yBAAyB,EAC5DD,EAAQ,UAAU,CAChB,OAAQD,EACR,OAAQE,CACV,CAAC,EAED,IAAMC,EAAW,IAAI,aAAa,CAEhC,IAAM,IACN,GAAK,IACL,GAAK,GAEL,IAAM,IACN,IAAM,GACN,GAAK,EACP,CAAC,EAEKC,EAAeJ,EAAO,aAAa,CAEvC,MAAO,gBAEP,KAAMG,EAAS,WAEf,MAAO,eAAe,OAAS,eAAe,QAChD,CAAC,EACDH,EAAO,MAAM,YAAYI,EAA2B,EAAGD,CAAQ,EAE/D,IAAME,EAA4C,CAEhD,YAAa,EACb,WAAY,CAAC,CACX,OAAQ,YACR,OAAQ,EACR,eAAgB,CAClB,CAAC,CACH,EAGMC,EAAe,IAAI,aAAa,CAACZ,EAAWA,CAAS,CAAC,EACtDa,EAAgBP,EAAO,aAAa,CACxC,MAAO,gBACP,KAAMM,EAAa,WACnB,MAAO,eAAe,QAAU,eAAe,QACjD,CAAC,EACDN,EAAO,MAAM,YAAYO,EAAe,EAAGD,CAAY,EAGvD,IAAME,EAAiB,IAAI,YAAYd,EAAYA,CAAS,EAEtDe,EAAqC,CACzCT,EAAO,aAAa,CAClB,MAAO,eACP,KAAMQ,EAAe,WACrB,MAAO,eAAe,QAAU,eAAe,QACjD,CAAC,EACDR,EAAO,aAAa,CAClB,MAAO,eACP,KAAMQ,EAAe,WACrB,MAAO,eAAe,QAAU,eAAe,QACjD,CAAC,CACH,EAEA,QAASE,EAAI,EAAGA,EAAIhB,EAAYA,EAAWgB,GAAK,EAC9CF,EAAeE,CAAC,EAAI,KAAK,OAAO,EAAI,GAAM,EAAI,EAEhDV,EAAO,MAAM,YAAYS,EAAiB,CAAC,EAAG,EAAGD,CAAc,EAC/DR,EAAO,MAAM,YAAYS,EAAiB,CAAC,EAAG,EAAGD,CAAc,EAG/D,IAAMG,EAAmBX,EAAO,mBAAmB,CACjD,MAAO,cACP,KAAMY,CACR,CAAC,EAKKC,EAAkBb,EAAO,sBAAsB,CACnD,MAAO,yBACP,QAAS,CAAC,CACR,QAAS,EACT,WAAY,eAAe,OAAS,eAAe,SAAW,eAAe,QAC7E,OAAQ,CAAE,KAAM,SAAU,CAC5B,EAAG,CACD,QAAS,EACT,WAAY,eAAe,OAAS,eAAe,QACnD,OAAQ,CAAE,KAAM,mBAAoB,CACtC,EAAG,CACD,QAAS,EACT,WAAY,eAAe,QAC3B,OAAQ,CAAE,KAAM,SAAU,CAC5B,CAAC,CACH,CAAC,EAEKc,EAAa,CACjBd,EAAO,gBAAgB,CACrB,MAAO,2BACP,OAAQa,EACR,QAAS,CAAC,CACR,QAAS,EACT,SAAU,CAAE,OAAQN,CAAc,CACpC,EAAG,CACD,QAAS,EACT,SAAU,CAAE,OAAQE,EAAiB,CAAC,CAAE,CAC1C,EAAG,CACD,QAAS,EACT,SAAU,CAAE,OAAQA,EAAiB,CAAC,CAAE,CAC1C,CAAC,CACH,CAAC,EACDT,EAAO,gBAAgB,CACrB,MAAO,2BAEP,OAAQa,EACR,QAAS,CAAC,CACR,QAAS,EACT,SAAU,CAAE,OAAQN,CAAc,CACpC,EAAG,CACD,QAAS,EACT,SAAU,CAAE,OAAQE,EAAiB,CAAC,CAAE,CAC1C,EAAG,CACD,QAAS,EACT,SAAU,CAAE,OAAQA,EAAiB,CAAC,CAAE,CAC1C,CAAC,CACH,CAAC,CACH,EAEMM,EAAiBf,EAAO,qBAAqB,CACjD,MAAO,6BACP,iBAAkB,CAACa,CAAe,CACpC,CAAC,EAEKG,EAAehB,EAAO,qBAAqB,CAC/C,MAAO,gBACP,OAAQe,EACR,OAAQ,CACN,OAAQJ,EACR,WAAY,aACZ,QAAS,CAACN,CAAkB,CAC9B,EACA,SAAU,CACR,OAAQM,EACR,WAAY,eACZ,QAAS,CAAC,CACR,OAAQT,CACV,CAAC,CACH,CACF,CAAC,EAEKe,EAAyBjB,EAAO,mBAAmB,CACvD,MAAO,kCACP,KAAMkB,CACR,CAAC,EAEKC,EAAqBnB,EAAO,sBAAsB,CACtD,MAAO,sBACP,OAAQe,EACR,QAAS,CACP,OAAQE,EACR,WAAY,aACd,CACF,CAAC,EAGD,SAASG,GAAa,CACpB,GAAI,CAACnB,EACH,MAAM,IAAI,MAAM,mBAAmB,EAGrC,IAAMoB,EAAUrB,EAAO,qBAAqB,EAGtCsB,EAAcD,EAAQ,iBAAiB,EAC7CC,EAAY,YAAYH,CAAkB,EAC1CG,EAAY,aAAa,EAAGR,EAAWlB,EAAO,CAAC,CAAC,EAChD,IAAM2B,EAAiB,KAAK,KAAK7B,EAAYG,CAAc,EAC3DyB,EAAY,mBAAmBC,EAAgBA,EAAgB,CAAC,EAEhED,EAAY,IAAI,EAEhB1B,IAGA,IAAM4B,EAAOH,EAAQ,gBAAgB,CACnC,MAAO,mBACP,iBAAkB,CAAC,CACjB,KAAMpB,EAAQ,kBAAkB,EAAE,WAAW,EAC7C,OAAQ,QACR,QAAS,QACT,WAAY,CAAE,EAAG,IAAM,EAAG,IAAM,EAAG,IAAM,EAAG,CAAI,CAClD,CAAC,CACH,CAAC,EAGDuB,EAAK,YAAYR,CAAY,EAC7BQ,EAAK,gBAAgB,EAAGpB,CAAY,EACpCoB,EAAK,aAAa,EAAGV,EAAWlB,EAAO,CAAC,CAAC,EACzC4B,EAAK,KAAKrB,EAAS,OAAS,EAAGT,EAAYA,CAAS,EAEpD8B,EAAK,IAAI,EAETxB,EAAO,MAAM,OAAO,CAACqB,EAAQ,OAAO,CAAC,CAAC,CACxC,CAGA,YAAYD,EAAYzB,CAAe",
  "names": ["cell_default", "simulation_default", "GRID_SIZE", "UPDATE_INTERVAL", "step", "WORKGROUP_SIZE", "canvas", "adapter", "device", "context", "canvasFormat", "vertices", "vertexBuffer", "vertexBufferLayout", "uniformArray", "uniformBuffer", "cellStateArray", "cellStateStorage", "i", "cellShaderModule", "cell_default", "bindGroupLayout", "bindGroups", "pipelineLayout", "cellPipeline", "simulationShaderModule", "simulation_default", "simulationPipeline", "updateGrid", "encoder", "computePass", "workgroupCount", "pass"]
}
